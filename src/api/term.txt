/**
 * Terminal API service for managing multiple WebSocket connections
 */

interface TerminalConnection {
  socket: WebSocket;
  isConnected: boolean;
  messageHandler: ((message: any) => void) | null;
  openHandler: (() => void) | null;
  closeHandler: (() => void) | null;
  errorHandler: ((event: Event) => void) | null;
}

class TerminalApiService {
  private connections: Map<string, TerminalConnection> = new Map();
  private activeConnection: string | null = null;

  /**
   * Check if a connection exists for a specific ID
   */
  hasConnection(connectionId: string): boolean {
    return this.connections.has(connectionId) && this.connections.get(connectionId)?.isConnected === true;
  }

  /**
   * Connect to the terminal WebSocket endpoint
   */
  connect(
    url: string,
    onMessage: (message: any) => void,
    onOpen: () => void,
    onClose: () => void,
    onError: (event: Event) => void
  ): void {
    // Use the active connection ID
    if (!this.activeConnection) {
      console.error('No active connection ID');
      return;
    }
    
    // If there's already a connection to this URL, reuse it
    if (this.connections.has(this.activeConnection) && this.connections.get(this.activeConnection)?.isConnected) {
      console.log('Reusing existing terminal connection');
      
      // Update the handlers
      const connection = this.connections.get(this.activeConnection);
      if (connection) {
        connection.messageHandler = onMessage;
        connection.openHandler = onOpen;
        connection.closeHandler = onClose;
        connection.errorHandler = onError;
        this.connections.set(this.activeConnection, connection);
      }
      
      // Notify that we're connected
      onOpen();
      return;
    }

    // Create a new WebSocket connection
    try {
      const socket = new WebSocket(url);
      
      this.connections.set(this.activeConnection, {
        socket,
        isConnected: false,
        messageHandler: onMessage,
        openHandler: onOpen,
        closeHandler: onClose,
        errorHandler: onError
      });

      // Set up event handlers
      socket.onopen = () => {
        const connection = this.connections.get(this.activeConnection!);
        if (connection) {
          connection.isConnected = true;
          this.connections.set(this.activeConnection!, connection);
          if (connection.openHandler) {
            connection.openHandler();
          }
        }
      };

      socket.onmessage = (event) => {
        const connection = this.connections.get(this.activeConnection!);
        if (connection && connection.messageHandler) {
          try {
            const data = JSON.parse(event.data);
            connection.messageHandler(data);
          } catch (error) {
            console.error('Error parsing terminal message:', error);
            connection.messageHandler({ type: 'error', data: 'Invalid message format' });
          }
        }
      };

      socket.onclose = () => {
        const connection = this.connections.get(this.activeConnection!);
        if (connection) {
          connection.isConnected = false;
          this.connections.set(this.activeConnection!, connection);
          if (connection.closeHandler) {
            connection.closeHandler();
          }
        }
      };

      socket.onerror = (event) => {
        const connection = this.connections.get(this.activeConnection!);
        if (connection && connection.errorHandler) {
          connection.errorHandler(event);
        }
      };
    } catch (error) {
      console.error('Error connecting to terminal:', error);
      const connection = this.connections.get(this.activeConnection!);
      if (connection && connection.errorHandler) {
        connection.errorHandler(new ErrorEvent('error', { error, message: 'Failed to connect to terminal' }));
      }
    }
  }

  /**
   * Switch to a different terminal connection
   */
  switchConnection(connectionId: string): boolean {
    if (this.connections.has(connectionId)) {
      this.activeConnection = connectionId;
      
      // Notify handlers that we're switching to this connection
      const connection = this.connections.get(connectionId);
      if (connection && connection.isConnected && connection.openHandler) {
        // Call the open handler to indicate connection is active
        connection.openHandler();
      }
      
      return true;
    }
    return false;
  }

  /**
   * Create a new terminal connection
   */
  createConnection(
    connectionId: string,
    url: string,
    onMessage: (message: any) => void,
    onOpen: () => void,
    onClose: () => void,
    onError: (event: Event) => void
  ): string {
    this.activeConnection = connectionId;
    this.connect(url, onMessage, onOpen, onClose, onError);
    return connectionId;
  }

  /**
   * Send input to the active terminal
   */
  sendInput(data: string): void {
    if (!this.activeConnection || !this.connections.has(this.activeConnection)) {
      console.error('Cannot send input: no active terminal connection');
      return;
    }

    const connection = this.connections.get(this.activeConnection);
    if (!connection || !connection.isConnected) {
      console.error('Cannot send input: terminal not connected');
      return;
    }

    try {
      connection.socket.send(JSON.stringify({
        type: 'stdin',
        data
      }));
    } catch (error) {
      console.error('Error sending input to terminal:', error);
    }
  }

  /**
   * Send resize event to the active terminal
   */
  sendResize(cols: number, rows: number): void {
    if (!this.activeConnection || !this.connections.has(this.activeConnection)) {
      return;
    }

    const connection = this.connections.get(this.activeConnection);
    if (!connection || !connection.isConnected) {
      return;
    }

    try {
      const resizeData = JSON.stringify({ width: cols, height: rows });
      connection.socket.send(JSON.stringify({
        type: 'resize',
        data: resizeData
      }));
    } catch (error) {
      console.error('Error sending resize to terminal:', error);
    }
  }

  /**
   * Send ping to the active terminal to keep the connection alive
   */
  sendPing(): void {
    if (!this.activeConnection || !this.connections.has(this.activeConnection)) {
      return;
    }

    const connection = this.connections.get(this.activeConnection);
    if (!connection || !connection.isConnected) {
      return;
    }

    try {
      connection.socket.send(JSON.stringify({
        type: 'ping',
        data: ''
      }));
    } catch (error) {
      console.error('Error sending ping to terminal:', error);
    }
  }

  /**
   * Check if the active terminal is connected
   */
  isConnected(): boolean {
    if (!this.activeConnection || !this.connections.has(this.activeConnection)) {
      return false;
    }

    const connection = this.connections.get(this.activeConnection);
    return connection ? connection.isConnected : false;
  }

  /**
   * Close a specific terminal connection
   */
  closeConnection(connectionId: string): void {
    const connection = this.connections.get(connectionId);
    if (connection) {
      try {
        connection.socket.close();
      } catch (error) {
        console.error(`Error closing terminal connection ${connectionId}:`, error);
      } finally {
        this.connections.delete(connectionId);
        if (this.activeConnection === connectionId) {
          this.activeConnection = null;
        }
      }
    }
  }

  /**
   * Close the active terminal connection
   */
  close(): void {
    if (this.activeConnection) {
      this.closeConnection(this.activeConnection);
    }
  }

  /**
   * Close all terminal connections
   */
  closeAll(): void {
    for (const connectionId of this.connections.keys()) {
      this.closeConnection(connectionId);
    }
    this.connections.clear();
    this.activeConnection = null;
  }
}

export const terminalApi = new TerminalApiService();