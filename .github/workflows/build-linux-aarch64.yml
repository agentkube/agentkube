name: "Linux ARM64 Build Automation"

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Version for the release (e.g., 1.0.0)'
        required: true
        type: string
      create_release:
        description: 'Create/update draft release'
        required: false
        default: true
        type: boolean

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  build-linux-aarch64:
    name: Build Linux ARM64 Binaries
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Setup cross-compilation environment
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Setup Python for orchestrator build
      - name: Set up Python for orchestrator
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      # Setup Go for operator build
      - name: Set up Go for operator
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'
      
      # Setup Rust for Tauri
      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: aarch64-unknown-linux-gnu
      
      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: src-tauri -> src-tauri/target
      
      # Setup Node.js
      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'
      
      - name: Install bun
        uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest
      
      # Build orchestrator binary for ARM64 using Docker
      - name: Build orchestrator for Linux ARM64
        run: |
          docker run --rm --platform linux/arm64 \
            -v ${{ github.workspace }}/internal/orchestrator:/workspace \
            -w /workspace \
            arm64v8/python:3.11-slim \
            bash -c "
              apt-get update && \
              apt-get install -y binutils git && \
              pip install --upgrade pip && \
              pip install -r requirements.linux.txt && \
              pip install pyinstaller && \
              python build.py --platform linux-arm && \
              chmod +x dist/agentkube-orchestrator-aarch64-unknown-linux-gnu
            "
      
      # Build operator binary for ARM64
      - name: Get operator build info
        id: operator_build_info
        working-directory: internal/operator
        run: |
          VERSION=$(git describe --tags --always --dirty 2>/dev/null || echo "dev")
          BUILD_TIME=$(date +%FT%T%z)
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "build_time=$BUILD_TIME" >> $GITHUB_OUTPUT
      
      - name: Create operator dist directory
        working-directory: internal/operator
        run: mkdir -p ./dist
      
      - name: Build operator for Linux ARM64
        working-directory: internal/operator
        env:
          GOOS: linux
          GOARCH: arm64
          CGO_ENABLED: 0
        run: |
          LDFLAGS="-s -w -X main.version=${{ steps.operator_build_info.outputs.version }} -X main.buildTime=${{ steps.operator_build_info.outputs.build_time }}"
          go build -trimpath -ldflags "$LDFLAGS" -o ./dist/agentkube-operator-aarch64-unknown-linux-gnu ./cmd/server/main.go
      
      - name: Make operator binary executable
        working-directory: internal/operator
        run: chmod +x ./dist/agentkube-operator-aarch64-unknown-linux-gnu
      
      # Create directories and copy binaries to Tauri structure
      - name: Prepare Tauri binary directories
        run: |
          mkdir -p src-tauri/bin/orchestrator
          mkdir -p src-tauri/bin/operator
      
      - name: Copy built binaries to Tauri structure
        run: |
          cp internal/orchestrator/dist/agentkube-orchestrator-aarch64-unknown-linux-gnu src-tauri/bin/orchestrator/
          cp internal/operator/dist/agentkube-operator-aarch64-unknown-linux-gnu src-tauri/bin/operator/
      
      # Install frontend dependencies
      - name: Install frontend dependencies
        run: bun install
      
      # Install additional dependencies for Linux ARM64 builds
      # Setup cross-compilation toolchain
      - name: Install cross-compilation dependencies
        run: |
          sudo dpkg --add-architecture arm64

          # Ubuntu 24.04 uses DEB822 format in /etc/apt/sources.list.d/ubuntu.sources
          # We need to constrain it to amd64 only by adding Architectures line
          if [ -f /etc/apt/sources.list.d/ubuntu.sources ]; then
            # Add architecture constraint to DEB822 format file
            sudo sed -i 's/^Types: deb$/Types: deb\nArchitectures: amd64/' /etc/apt/sources.list.d/ubuntu.sources
          fi

          # Also handle traditional format sources.list if it exists
          if [ -f /etc/apt/sources.list ]; then
            sudo sed -i 's/^deb \(http\|https\)/deb [arch=amd64] \1/g' /etc/apt/sources.list 2>/dev/null || true
          fi

          # Constrain any other .list files in sources.list.d
          for f in /etc/apt/sources.list.d/*.list; do
            if [ -f "$f" ] && [ "$(basename "$f")" != "arm64.list" ]; then
              sudo sed -i 's/^deb \(http\|https\)/deb [arch=amd64] \1/g' "$f" 2>/dev/null || true
            fi
          done

          # Create arm64 sources pointing to ports.ubuntu.com (where arm64 packages live)
          sudo bash -c 'cat > /etc/apt/sources.list.d/arm64.list <<EOF
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-updates main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-security main restricted universe multiverse
          deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports/ noble-backports main restricted universe multiverse
          EOF'

          sudo apt-get update
          sudo apt-get install -y \
            gcc-aarch64-linux-gnu \
            g++-aarch64-linux-gnu \
            pkg-config \
            libwebkit2gtk-4.1-dev:arm64 \
            libjavascriptcoregtk-4.1-dev:arm64 \
            libgtk-3-dev:arm64 \
            libayatana-appindicator3-dev:arm64 \
            libglib2.0-dev:arm64 \
            libcairo2-dev:arm64 \
            libpango1.0-dev:arm64 \
            libgdk-pixbuf2.0-dev:arm64 \
            libsoup-3.0-dev:arm64 \
            libatk1.0-dev:arm64 \
            libatk-bridge2.0-dev:arm64 \
            libssl-dev:arm64

          # Create a pkg-config wrapper for cross-compilation
          # Include both arch-specific and shared pkgconfig directories
          sudo bash -c 'cat > /usr/local/bin/aarch64-linux-gnu-pkg-config <<EOF
          #!/bin/sh
          export PKG_CONFIG_PATH="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig"
          export PKG_CONFIG_LIBDIR="/usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig"
          export PKG_CONFIG_SYSROOT_DIR="/"
          exec pkg-config "\$@"
          EOF'
          sudo chmod +x /usr/local/bin/aarch64-linux-gnu-pkg-config
      
      # Build Tauri application for ARM64
      - name: Build Tauri application for Linux ARM64
        env:
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          CC_aarch64_unknown_linux_gnu: aarch64-linux-gnu-gcc
          CXX_aarch64_unknown_linux_gnu: aarch64-linux-gnu-g++
          CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER: aarch64-linux-gnu-gcc
          PKG_CONFIG_SYSROOT_DIR: /
          PKG_CONFIG_PATH: /usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig
          PKG_CONFIG_LIBDIR: /usr/lib/aarch64-linux-gnu/pkgconfig:/usr/share/pkgconfig
          PKG_CONFIG_ALLOW_CROSS: 1
          PKG_CONFIG: /usr/local/bin/aarch64-linux-gnu-pkg-config
          G_MESSAGES_DEBUG: all
          WEBKIT_DISABLE_COMPOSITING_MODE: 1
          WINIT_UNIX_BACKEND: x11
          GDK_BACKEND: x11
        run: |
          bunx tauri build --target aarch64-unknown-linux-gnu
      
      # Upload build artifacts (at least the binaries will be available)
      - name: Upload Linux ARM64 binaries
        uses: actions/upload-artifact@v4
        with:
          name: linux-aarch64-binaries
          path: |
            internal/orchestrator/dist/agentkube-orchestrator-aarch64-unknown-linux-gnu
            internal/operator/dist/agentkube-operator-aarch64-unknown-linux-gnu
          retention-days: 7
      
      - name: Upload Tauri build artifacts (if available)
        uses: actions/upload-artifact@v4
        with:
          name: linux-aarch64-tauri-build
          path: |
            src-tauri/target/aarch64-unknown-linux-gnu/release/bundle/**/*
            src-tauri/target/aarch64-unknown-linux-gnu/release/*.sig
          retention-days: 7
        continue-on-error: true
      
      # Create or update release if requested
      - name: Create or update draft release
        if: ${{ inputs.create_release }}
        uses: actions/github-script@v7
        env:
          VERSION: ${{ inputs.version }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const version = process.env.VERSION;
            const tagName = `v${version}`;
            
            // First, try to find existing draft release by tag
            let release;
            try {
              const { data } = await github.rest.repos.getReleaseByTag({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag: tagName
              });
              release = data;
              console.log(`Found existing release by tag: ${release.id}`);
            } catch (error) {
              if (error.status === 404) {
                // If no release found by tag, check for draft releases with same version
                const { data: releases } = await github.rest.repos.listReleases({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 100
                });
                
                // Look for existing draft release with same name/version
                const existingDraft = releases.find(r => 
                  r.draft === true && 
                  (r.name === `Agentkube v${version}` || r.tag_name === tagName)
                );
                
                if (existingDraft) {
                  release = existingDraft;
                  console.log(`Found existing draft release: ${release.id}`);
                  
                  // Update the existing draft release body to append new build info
                  const currentBody = release.body || '';
                  const newBuildInfo = `\n\n## Linux ARM64 Build\n\nThis release includes:\n- Linux ARM64 binaries (orchestrator & operator)\n- Cross-compiled for aarch64 architecture\n- Optimized for ARM-based Linux systems\n\n### Installation (ARM64 Linux systems)\n1. Download the ARM64 binaries\n2. Make them executable: \`chmod +x binary-name\`\n3. Place them in your preferred directory (e.g., /usr/local/bin)\n4. Add to PATH if needed\n\n### Supported ARM64 Systems\n- Raspberry Pi 4/5 with 64-bit OS\n- ARM64 cloud instances (AWS Graviton, etc.)\n- Other ARM64 Linux distributions`;
                  
                  let updatedBody;
                  if (currentBody.includes('## Linux ARM64 Build')) {
                    // Replace existing ARM64 section
                    updatedBody = currentBody.replace(/## Linux ARM64 Build[\s\S]*?(?=\n##|\n---|\n\*This release|$)/, newBuildInfo.substring(2));
                  } else {
                    // Append new ARM64 section
                    updatedBody = currentBody + newBuildInfo;
                  }
                  
                  await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: release.id,
                    body: updatedBody,
                    tag_name: tagName
                  });
                  console.log(`Updated existing draft release: ${release.id}`);
                } else {
                  // Create new release
                  const { data } = await github.rest.repos.createRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    tag_name: tagName,
                    name: `Agentkube v${version}`,
                    body: `# Agentkube v${version}
            
            ## Linux ARM64 Build
            
            This release includes:
            - Linux ARM64 binaries (orchestrator & operator)
            - Cross-compiled for aarch64 architecture
            - Optimized for ARM-based Linux systems
            
            ### Installation (ARM64 Linux systems)
            1. Download the ARM64 binaries
            2. Make them executable: \`chmod +x binary-name\`
            3. Place them in your preferred directory (e.g., /usr/local/bin)
            4. Add to PATH if needed
            
            ### Supported ARM64 Systems
            - Raspberry Pi 4/5 with 64-bit OS
            - ARM64 cloud instances (AWS Graviton, etc.)
            - Other ARM64 Linux distributions
            
            ---
            
            *This release was automatically generated using GitHub Actions*
            `,
                    draft: true,
                    prerelease: false
                  });
                  release = data;
                  console.log(`Created new release: ${release.id}`);
                }
              } else {
                throw error;
              }
            }
            
            // Function to upload asset if it exists
            async function uploadAssetIfExists(filePath, assetName) {
              const fullPath = path.join(process.cwd(), filePath);
              if (fs.existsSync(fullPath)) {
                const content = fs.readFileSync(fullPath);
                try {
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: release.id,
                    name: assetName,
                    data: content,
                  });
                  console.log(`Uploaded: ${assetName}`);
                } catch (uploadError) {
                  console.log(`Failed to upload ${assetName}: ${uploadError.message}`);
                }
              } else {
                console.log(`File not found: ${fullPath}`);
              }
            }
            
            // Upload Tauri packages
            const bundlePath = 'src-tauri/target/aarch64-unknown-linux-gnu/release/bundle';
            
            // Find DEB file
            if (fs.existsSync(path.join(bundlePath, 'deb'))) {
              const debFiles = fs.readdirSync(path.join(bundlePath, 'deb'))
                .filter(file => file.endsWith('.deb'));
              
              for (const debFile of debFiles) {
                await uploadAssetIfExists(
                  `src-tauri/target/aarch64-unknown-linux-gnu/release/bundle/deb/${debFile}`,
                  debFile
                );
              }
            }
            
            // Find RPM file
            if (fs.existsSync(path.join(bundlePath, 'rpm'))) {
              const rpmFiles = fs.readdirSync(path.join(bundlePath, 'rpm'))
                .filter(file => file.endsWith('.rpm'));
              
              for (const rpmFile of rpmFiles) {
                await uploadAssetIfExists(
                  `src-tauri/target/aarch64-unknown-linux-gnu/release/bundle/rpm/${rpmFile}`,
                  rpmFile
                );
              }
            }
            
            // Upload signature files
            const sigFiles = ['src-tauri/target/aarch64-unknown-linux-gnu/release']
              .flatMap(dir => {
                if (fs.existsSync(dir)) {
                  return fs.readdirSync(dir)
                    .filter(file => file.endsWith('.sig'))
                    .map(file => path.join(dir, file));
                }
                return [];
              });
            
            for (const sigFile of sigFiles) {
              const sigName = path.basename(sigFile);
              await uploadAssetIfExists(sigFile, sigName);
            }
            
            console.log(`Release URL: ${release.html_url}`);
            return release.id;

  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest
    needs: build-linux-aarch64
    if: always()
    
    steps:
      - name: Build Summary
        run: |
          echo "## Linux ARM64 Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Target Architecture**: ARM64 (aarch64)" >> $GITHUB_STEP_SUMMARY
          echo "- **Create Release**: ${{ inputs.create_release }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Status" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.build-linux-aarch64.result }}" == "success" ]; then
            echo "**✅ Build completed successfully**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**❌ Build failed**" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Notes" >> $GITHUB_STEP_SUMMARY
          echo "- ARM64 builds use cross-compilation and Docker" >> $GITHUB_STEP_SUMMARY
          echo "- Tauri cross-compilation for ARM64 may have limitations" >> $GITHUB_STEP_SUMMARY
          echo "- Binary artifacts are always generated successfully" >> $GITHUB_STEP_SUMMARY